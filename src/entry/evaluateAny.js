// we keep evaluateAny.js separate from functionsAny.js because it contains
// a circular reference between math -> evaluate -> simplify -> evaluate
// so it is impure.

import { createApplyTransform } from '../expression/transform/apply.transform'
import { createColumnTransform } from '../expression/transform/column.transform'
import { createConcatTransform } from '../expression/transform/concat.transform'
import { createFilterTransform } from '../expression/transform/filter.transform'
import { createForEachTransform } from '../expression/transform/forEach.transform'
import { createIndexTransform } from '../expression/transform/index.transform'
import { createMapTransform } from '../expression/transform/map.transform'
import { createMaxTransform } from '../expression/transform/max.transform'
import { createMeanTransform } from '../expression/transform/mean.transform'
import { createMinTransform } from '../expression/transform/min.transform'
import { createRangeTransform } from '../expression/transform/range.transform'
import { createRowTransform } from '../expression/transform/row.transform'
import { createSubsetTransform } from '../expression/transform/subset.transform'
import { createSumTransform } from '../expression/transform/sum.transform'
import { createStdTransform } from '../expression/transform/std.transform'
import { createVarianceTransform } from '../expression/transform/variance.transform'
import { createNode } from '../expression/node/Node'
import { createAccessorNode } from '../expression/node/AccessorNode'
import { createArrayNode } from '../expression/node/ArrayNode'
import { createAssignmentNode } from '../expression/node/AssignmentNode'
import { createBlockNode } from '../expression/node/BlockNode'
import { createConditionalNode } from '../expression/node/ConditionalNode'
import { createConstantNode } from '../expression/node/ConstantNode'
import { createFunctionAssignmentNode } from '../expression/node/FunctionAssignmentNode'
import { createIndexNode } from '../expression/node/IndexNode'
import { createObjectNode } from '../expression/node/ObjectNode'
import { createOperatorNode } from '../expression/node/OperatorNode'
import { createParenthesisNode } from '../expression/node/ParenthesisNode'
import { createRangeNode } from '../expression/node/RangeNode'
import { createRelationalNode } from '../expression/node/RelationalNode'
import { createSymbolNode } from '../expression/node/SymbolNode'
import { createFunctionNode } from '../expression/node/FunctionNode'
import { createParse } from '../expression/parse'
import { createCompile } from '../expression/function/compile'
import { createEvaluate } from '../expression/function/evaluate'
import { createParserClass } from '../expression/Parser'
import { createParser } from '../expression/function/parser'
import { createHelpClass } from '../expression/Help'
import { createChainClass } from '../type/chain/Chain'
import { createHelp } from '../expression/function/help'
import { createChain } from '../type/chain/function/chain'
import { createSimplify } from '../function/algebra/simplify'
import { createDerivative } from '../function/algebra/derivative'
import { createRationalize } from '../function/algebra/rationalize'
import { createReviver } from '../json/reviver'
import {
  _false,
  _Infinity,
  _NaN,
  _null,
  _true,
  abs,
  acos,
  acosh,
  acot,
  acoth,
  acsc,
  acsch,
  add,
  addScalar,
  and,
  apply,
  arg,
  asec,
  asech,
  asin,
  asinh,
  atan,
  atan2,
  atanh,
  atomicMass,
  avogadro,
  bellNumbers,
  BigNumber,
  bignumber,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  bohrMagneton,
  bohrRadius,
  boltzmann,
  boolean,
  catalan,
  cbrt,
  ceil,
  classicalElectronRadius,
  clone,
  combinations,
  compare,
  compareNatural,
  compareText,
  Complex,
  complex,
  composition,
  concat,
  conductanceQuantum,
  config,
  conj,
  cos,
  cosh,
  cot,
  coth,
  coulomb,
  createUnit,
  cross,
  csc,
  csch,
  ctranspose,
  cube,
  deepEqual,
  DenseMatrix,
  det,
  deuteronMass,
  diag,
  distance,
  divide,
  divideScalar,
  dot,
  dotDivide,
  dotMultiply,
  dotPow,
  e,
  efimovFactor,
  electricConstant,
  electronMass,
  elementaryCharge,
  equal,
  equalScalar,
  equalText,
  erf,
  exp,
  expm,
  expm1,
  eye,
  factorial,
  faraday,
  fermiCoupling,
  FibonacciHeap,
  filter,
  fineStructure,
  firstRadiation,
  fix,
  flatten,
  floor,
  forEach,
  format,
  Fraction,
  fraction,
  gamma,
  gasConstant,
  gcd,
  getMatrixDataType,
  gravitationConstant,
  gravity,
  hartreeEnergy,
  hasNumericValue,
  hypot,
  i,
  identity,
  im,
  ImmutableDenseMatrix,
  Index,
  index,
  intersect,
  inv,
  inverseConductanceQuantum,
  isInteger,
  isNaN,
  isNegative,
  isNumeric,
  isPositive,
  isPrime,
  isZero,
  kldivergence,
  klitzing,
  kron,
  larger,
  largerEq,
  lcm,
  leftShift,
  LN10,
  LN2,
  log,
  log10,
  LOG10E,
  log1p,
  log2,
  LOG2E,
  loschmidt,
  lsolve,
  lup,
  lusolve,
  mad,
  magneticConstant,
  magneticFluxQuantum,
  map,
  Matrix,
  matrix,
  max,
  mean,
  median,
  min,
  mod,
  mode,
  molarMass,
  molarMassC12,
  molarPlanckConstant,
  molarVolume,
  multinomial,
  multiply,
  multiplyScalar,
  neutronMass,
  norm,
  not,
  nthRoot,
  nthRoots,
  nuclearMagneton,
  number,
  numeric,
  ones,
  or,
  partitionSelect,
  permutations,
  phi,
  pi,
  pickRandom,
  planckCharge,
  planckConstant,
  planckLength,
  planckMass,
  planckTemperature,
  planckTime,
  pow,
  print,
  prod,
  protonMass,
  qr,
  quantileSeq,
  quantumOfCirculation,
  random,
  randomInt,
  Range,
  range,
  re,
  reducedPlanckConstant,
  reshape,
  resize,
  ResultSet,
  rightArithShift,
  rightLogShift,
  round,
  rydberg,
  sackurTetrode,
  sec,
  sech,
  secondRadiation,
  setCartesian,
  setDifference,
  setDistinct,
  setIntersect,
  setIsSubset,
  setMultiplicity,
  setPowerset,
  setSize,
  setSymDifference,
  setUnion,
  sign,
  sin,
  sinh,
  size,
  slu,
  smaller,
  smallerEq,
  sort,
  Spa,
  sparse,
  SparseMatrix,
  speedOfLight,
  splitUnit,
  sqrt,
  SQRT1_2,
  SQRT2,
  sqrtm,
  square,
  squeeze,
  std,
  stefanBoltzmann,
  stirlingS2,
  string,
  subset,
  subtract,
  sum,
  tan,
  tanh,
  tau,
  thomsonCrossSection,
  to,
  trace,
  transpose,
  typed,
  typeOf,
  unaryMinus,
  unaryPlus,
  unequal,
  Unit,
  unit,
  usolve,
  vacuumImpedance,
  variance,
  version,
  weakMixingAngle,
  wienDisplacement,
  xgcd,
  xor,
  zeros
} from './functionsAny'

const math = {} // NOT pure!
const mathWithTransform = {} // NOT pure!

// expression (4)
export const Node = /* #__PURE__ */ createNode({ mathWithTransform })
export const AccessorNode = /* #__PURE__ */ createAccessorNode({ subset, Node })
export const ArrayNode = /* #__PURE__ */ createArrayNode({ Node })
export const AssignmentNode = /* #__PURE__ */ createAssignmentNode({ subset, matrix, Node })
export const BlockNode = /* #__PURE__ */ createBlockNode({ ResultSet, Node })
export const ConditionalNode = /* #__PURE__ */ createConditionalNode({ Node })
export const ConstantNode = /* #__PURE__ */ createConstantNode({ Node })
export const FunctionAssignmentNode = /* #__PURE__ */ createFunctionAssignmentNode({ typed, Node })
export const IndexNode = /* #__PURE__ */ createIndexNode({ Range, Node })
export const ObjectNode = /* #__PURE__ */ createObjectNode({ Node })
export const OperatorNode = /* #__PURE__ */ createOperatorNode({ Node })
export const ParenthesisNode = /* #__PURE__ */ createParenthesisNode({ Node })
export const RangeNode = /* #__PURE__ */ createRangeNode({ Node })
export const RelationalNode = /* #__PURE__ */ createRelationalNode({ Node })
export const SymbolNode = /* #__PURE__ */ createSymbolNode({ math, Unit, Node })
export const FunctionNode = /* #__PURE__ */ createFunctionNode({ math, Node, SymbolNode })
export const parse = /* #__PURE__ */ createParse({
  typed,
  config,
  numeric,
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode
})
export const compile = /* #__PURE__ */ createCompile({ typed, parse })
export const evaluate = /* #__PURE__ */ createEvaluate({ typed, parse })
export const Parser = /* #__PURE__ */ createParserClass({ parse })

// create (4)
export const parser = /* #__PURE__ */ createParser({ math, typed, Parser })

// class (4)
export const Help = /* #__PURE__ */ createHelpClass({ parse })
export const Chain = /* #__PURE__ */ createChainClass({ math })

// type (4)
export { embeddedDocs as docs } from '../expression/embeddedDocs/embeddedDocs'
export const help = /* #__PURE__ */ createHelp({ math, typed, Help })
export const chain = /* #__PURE__ */ createChain({ typed, Chain })

// algebra (4)
export const simplify = /* #__PURE__ */ createSimplify({
  config,
  typed,
  parse,
  add,
  subtract,
  multiply,
  divide,
  pow,
  isZero,
  equal,
  fraction,
  bignumber,
  math,
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode
})
export const derivative = /* #__PURE__ */ createDerivative({
  config,
  typed,
  parse,
  simplify,
  equal,
  isZero,
  numeric,
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode
})
export const rationalize = /* #__PURE__ */ createRationalize({
  config,
  typed,
  simplify,
  parse,
  add,
  subtract,
  multiply,
  divide,
  pow,
  isZero,
  equal,
  fraction,
  bignumber,
  math,
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode
})

// ----------------------------------------------------------------------------
// json

export const reviver = /* #__PURE__ */ createReviver({
  classes: {
    BigNumber,
    Chain,
    Complex,
    Fraction,
    Matrix,
    DenseMatrix,
    SparseMatrix,
    Spa,
    FibonacciHeap,
    ImmutableDenseMatrix,
    Index,
    Range,
    ResultSet,
    Unit,
    Help
  },
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode
})

Object.assign(math, {
  E: e,
  'Infinity': _Infinity,
  LN10,
  LN2,
  LOG10E,
  LOG2E,
  'NaN': _NaN,
  PI: pi,
  SQRT1_2,
  SQRT2,
  abs,
  acos,
  acosh,
  acot,
  acoth,
  acsc,
  acsch,
  add,
  addScalar,
  and,
  arg,
  asec,
  asech,
  asin,
  asinh,
  atan,
  atan2,
  atanh,
  atomicMass,
  avogadro,
  bellNumbers,
  bignumber,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  bohrMagneton,
  bohrRadius,
  boltzmann,
  boolean,
  catalan,
  cbrt,
  ceil,
  chain,
  classicalElectronRadius,
  clone,
  combinations,
  compare,
  compareNatural,
  compareText,
  compile,
  complex,
  composition,
  concat,
  conductanceQuantum,
  config,
  conj,
  cos,
  cosh,
  cot,
  coth,
  coulomb,
  createUnit,
  cross,
  csc,
  csch,
  ctranspose,
  cube,
  deepEqual,
  derivative,
  det,
  deuteronMass,
  diag,
  distance,
  divide,
  divideScalar,
  dot,
  dotDivide,
  dotMultiply,
  dotPow,
  e,
  efimovFactor,
  electricConstant,
  electronMass,
  elementaryCharge,
  equal,
  equalScalar,
  equalText,
  erf,
  'eval': evaluate,
  evaluate,
  exp,
  expm,
  expm1,
  eye,
  factorial,
  'false': _false,
  faraday,
  fermiCoupling,
  filter,
  fineStructure,
  firstRadiation,
  fix,
  flatten,
  floor,
  forEach,
  format,
  fraction,
  gamma,
  gasConstant,
  gcd,
  getMatrixDataType,
  gravitationConstant,
  gravity,
  hartreeEnergy,
  hasNumericValue,
  help,
  hypot,
  i,
  identity,
  im,
  index,
  intersect,
  inv,
  inverseConductanceQuantum,
  isInteger,
  isNaN,
  isNegative,
  isNumeric,
  isPositive,
  isPrime,
  isZero,
  kldivergence,
  klitzing,
  kron,
  larger,
  largerEq,
  lcm,
  leftShift,
  log,
  log10,
  log1p,
  log2,
  loschmidt,
  lsolve,
  lup,
  lusolve,
  mad,
  magneticConstant,
  magneticFluxQuantum,
  map,
  matrix,
  max,
  mean,
  median,
  min,
  mod,
  mode,
  molarMass,
  molarMassC12,
  molarPlanckConstant,
  molarVolume,
  multinomial,
  multiply,
  multiplyScalar,
  neutronMass,
  norm,
  not,
  nthRoot,
  nthRoots,
  nuclearMagneton,
  'null': _null,
  number,
  numeric,
  ones,
  or,
  parse,
  parser,
  partitionSelect,
  permutations,
  phi,
  pi,
  pickRandom,
  planckCharge,
  planckConstant,
  planckLength,
  planckMass,
  planckTemperature,
  planckTime,
  pow,
  print,
  prod,
  protonMass,
  qr,
  quantileSeq,
  quantumOfCirculation,
  random,
  randomInt,
  range,
  rationalize,
  re,
  reducedPlanckConstant,
  reshape,
  resize,
  reviver,
  rightArithShift,
  rightLogShift,
  round,
  rydberg,
  sackurTetrode,
  sec,
  sech,
  secondRadiation,
  setCartesian,
  setDifference,
  setDistinct,
  setIntersect,
  setIsSubset,
  setMultiplicity,
  setPowerset,
  setSize,
  setSymDifference,
  setUnion,
  sign,
  simplify,
  sin,
  sinh,
  size,
  slu,
  smaller,
  smallerEq,
  sort,
  sparse,
  speedOfLight,
  splitUnit,
  sqrt,
  sqrtm,
  square,
  squeeze,
  std,
  stefanBoltzmann,
  stirlingS2,
  string,
  subset,
  subtract,
  sum,
  tan,
  tanh,
  tau,
  thomsonCrossSection,
  to,
  trace,
  transpose,
  'true': _true,
  typeOf,
  'typeof': typeOf,
  typed,
  unaryMinus,
  unaryPlus,
  unequal,
  unit,
  usolve,
  vacuumImpedance,
  variance,
  'var': variance,
  version,
  weakMixingAngle,
  wienDisplacement,
  xgcd,
  xor,
  zeros
})

Object.assign(mathWithTransform, math, {
  apply: /* #__PURE__ */ createApplyTransform({ typed, isInteger }),
  column: /* #__PURE__ */ createColumnTransform({ typed, Index, matrix, range }),
  concat: /* #__PURE__ */ createConcatTransform({ typed, matrix, isInteger }),
  filter: /* #__PURE__ */ createFilterTransform({ typed }),
  forEach: /* #__PURE__ */ createForEachTransform({ typed }),
  index: /* #__PURE__ */ createIndexTransform({ Index }),
  map: /* #__PURE__ */ createMapTransform({ typed }),
  max: /* #__PURE__ */ createMaxTransform({ typed, larger }),
  mean: /* #__PURE__ */ createMeanTransform({ typed, add, divide }),
  min: /* #__PURE__ */ createMinTransform({ typed, smaller }),
  range: /* #__PURE__ */ createRangeTransform({ typed, config, matrix, bignumber, smaller, smallerEq, larger, largerEq }),
  row: /* #__PURE__ */ createRowTransform({ typed, Index, matrix, range }),
  subset: /* #__PURE__ */ createSubsetTransform({ typed, matrix }),
  sum: /* #__PURE__ */ createSumTransform({ typed, config, add, bignumber, fraction }),
  std: /* #__PURE__ */ createStdTransform({ typed, sqrt, variance }),
  variance: /* #__PURE__ */ createVarianceTransform({ typed, add, subtract, multiply, divide, apply, isNaN })
})

Chain.createProxy(math)
