import { config } from './configReadonly'
import { e, phi, pi, tau } from '../plain/number'
import { version } from '../version'
import { createApplyTransform } from '../expression/transform/apply.transform'
import { createFilterTransform } from '../expression/transform/filter.transform'
import { createForEachTransform } from '../expression/transform/forEach.transform'
import { createMapTransform } from '../expression/transform/map.transform'
import { createMaxTransform } from '../expression/transform/max.transform'
import { createMeanTransform } from '../expression/transform/mean.transform'
import { createMinTransform } from '../expression/transform/min.transform'
import { createRangeTransform } from '../expression/transform/range.transform'
import { createSubsetTransform } from '../expression/transform/subset.transform'
import { createSumTransform } from '../expression/transform/sum.transform'
import { createStdTransform } from '../expression/transform/std.transform'
import { createVarianceTransform } from '../expression/transform/variance.transform'
import { createNode } from '../expression/node/Node'
import { createAccessorNode } from '../expression/node/AccessorNode'
import { createArrayNode } from '../expression/node/ArrayNode'
import { createAssignmentNode } from '../expression/node/AssignmentNode'
import { createBlockNode } from '../expression/node/BlockNode'
import { createConditionalNode } from '../expression/node/ConditionalNode'
import { createConstantNode } from '../expression/node/ConstantNode'
import { createFunctionAssignmentNode } from '../expression/node/FunctionAssignmentNode'
import { createIndexNode } from '../expression/node/IndexNode'
import { createObjectNode } from '../expression/node/ObjectNode'
import { createOperatorNode } from '../expression/node/OperatorNode'
import { createParenthesisNode } from '../expression/node/ParenthesisNode'
import { createRangeNode } from '../expression/node/RangeNode'
import { createRelationalNode } from '../expression/node/RelationalNode'
import { createSymbolNode } from '../expression/node/SymbolNode'
import { createFunctionNode } from '../expression/node/FunctionNode'
import { createParse } from '../expression/parse'
import { createCompile } from '../expression/function/compile'
import { createEvaluate } from '../expression/function/evaluate'
import { createParserClass } from '../expression/Parser'
import { createParser } from '../expression/function/parser'
import { createHelpClass } from '../expression/Help'
import { createChainClass } from '../type/chain/Chain'
import { createHelp } from '../expression/function/help'
import { createChain } from '../type/chain/function/chain'
import { createSimplify } from '../function/algebra/simplify'
import { createDerivative } from '../function/algebra/derivative'
import { createRationalize } from '../function/algebra/rationalize'
import { createReviver } from '../json/reviver'
import {
  _false,
  _Infinity,
  _NaN,
  _null,
  _true,
  abs,
  acos,
  acosh,
  acot,
  acoth,
  acsc,
  acsch,
  add,
  addScalar,
  and, apply,
  asec,
  asech,
  asin,
  asinh,
  atan,
  atan2,
  atanh,
  bellNumbers,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  boolean,
  catalan,
  cbrt,
  ceil,
  clone,
  combinations,
  compare,
  compareNatural,
  compareText,
  composition,
  cos,
  cosh,
  cot,
  coth,
  csc,
  csch,
  cube,
  deepEqual,
  divide,
  divideScalar,
  equal,
  equalScalar,
  equalText,
  erf,
  exp,
  expm1,
  factorial,
  filter,
  fix,
  floor,
  forEach,
  format,
  gamma,
  gcd,
  hasNumericValue,
  hypot,
  isInteger,
  isNaN,
  isNegative,
  isNumeric,
  isPositive,
  isPrime,
  isZero,
  larger,
  largerEq,
  lcm,
  leftShift,
  LN10,
  LN2,
  log,
  log10,
  LOG10E,
  log1p,
  log2,
  LOG2E,
  mad,
  matrix,
  max,
  mean,
  median,
  min,
  mod,
  mode,
  multinomial,
  multiply,
  multiplyScalar,
  norm,
  not,
  nthRoot,
  number,
  numeric,
  or,
  partitionSelect,
  permutations,
  pickRandom,
  pow,
  print,
  prod,
  quantileSeq,
  random,
  randomInt, Range,
  range, ResultSet,
  rightArithShift,
  rightLogShift,
  round,
  sec,
  sech,
  sign,
  sin,
  sinh,
  smaller,
  smallerEq,
  sqrt,
  SQRT1_2,
  SQRT2,
  square,
  std,
  stirlingS2,
  string,
  subset,
  subtract,
  sum,
  tan,
  tanh,
  typed,
  typeOf,
  unaryMinus,
  unaryPlus,
  unequal, variance, xgcd, xor
} from './functionsNumber.generated'

const math = {} // NOT pure!
const mathWithTransform = {} // NOT pure!

// expression (4)
export const Node = /* #__PURE__ */ createNode({ mathWithTransform })
export const AccessorNode = /* #__PURE__ */ createAccessorNode({ subset, Node }) // FIXME: subset is heavy-weight
export const ArrayNode = /* #__PURE__ */ createArrayNode({ Node })
export const AssignmentNode = /* #__PURE__ */ createAssignmentNode({ subset, matrix, Node }) // FIXME: subset is heavy-weight
export const BlockNode = /* #__PURE__ */ createBlockNode({ ResultSet, Node })
export const ConditionalNode = /* #__PURE__ */ createConditionalNode({ Node })
export const ConstantNode = /* #__PURE__ */ createConstantNode({ Node })
export const FunctionAssignmentNode = /* #__PURE__ */ createFunctionAssignmentNode({ typed, Node })
export const IndexNode = /* #__PURE__ */ createIndexNode({ Range, Node })
export const ObjectNode = /* #__PURE__ */ createObjectNode({ Node })
export const OperatorNode = /* #__PURE__ */ createOperatorNode({ Node })
export const ParenthesisNode = /* #__PURE__ */ createParenthesisNode({ Node })
export const RangeNode = /* #__PURE__ */ createRangeNode({ Node })
export const RelationalNode = /* #__PURE__ */ createRelationalNode({ Node })
export const SymbolNode = /* #__PURE__ */ createSymbolNode({ math, Node })
export const FunctionNode = /* #__PURE__ */ createFunctionNode({ math, Node, SymbolNode })
export const parse = /* #__PURE__ */ createParse({
  typed,
  config,
  numeric,
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode
})
export const compile = /* #__PURE__ */ createCompile({ typed, parse })
export const evaluate = /* #__PURE__ */ createEvaluate({ typed, parse })
export const Parser = /* #__PURE__ */ createParserClass({ parse })

// create (4)
export const parser = /* #__PURE__ */ createParser({ math, typed, Parser })

// class (4)
export const Help = /* #__PURE__ */ createHelpClass({ parse })
export const Chain = /* #__PURE__ */ createChainClass({ math })

// type (4)
export { embeddedDocs as docs } from '../expression/embeddedDocs/embeddedDocs'
export const help = /* #__PURE__ */ createHelp({ math, typed, Help })
export const chain = /* #__PURE__ */ createChain({ typed, Chain })

// algebra (4)
export const simplify = /* #__PURE__ */ createSimplify({
  config,
  typed,
  parse,
  add,
  subtract,
  multiply,
  divide,
  pow,
  isZero,
  equal,
  math,
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode
})
export const derivative = /* #__PURE__ */ createDerivative({
  config,
  typed,
  parse,
  simplify,
  equal,
  isZero,
  numeric,
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode
})
export const rationalize = /* #__PURE__ */ createRationalize({
  config,
  typed,
  simplify,
  parse,
  add,
  subtract,
  multiply,
  divide,
  pow,
  isZero,
  equal,
  math,
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode
})

// ----------------------------------------------------------------------------
// json

export const reviver = /* #__PURE__ */ createReviver({
  classes: {
    // BigNumber,
    Chain,
    // Complex,
    // Fraction,
    // Matrix,
    // DenseMatrix,
    // SparseMatrix,
    // Spa,
    // FibonacciHeap,
    // ImmutableDenseMatrix,
    // Index,
    Range,
    // ResultSet,
    // Unit,
    Help
  },
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode
})

Object.assign(math, {
  Infinity: _Infinity,
  LN10,
  LN2,
  LOG10E,
  LOG2E,
  NaN: _NaN,
  SQRT2,
  SQRT1_2,
  abs,
  acos,
  acosh,
  acot,
  acoth,
  acsc,
  acsch,
  add,
  addScalar,
  and,
  // arg,
  asec,
  asech,
  asin,
  asinh,
  atan,
  atan2,
  atanh,
  // atomicMass,
  // avogadro,
  bellNumbers,
  // bignumber,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  // bohrMagneton,
  // bohrRadius,
  // boltzmann,
  boolean,
  catalan,
  cbrt,
  ceil,
  // classicalElectronRadius,
  clone,
  combinations,
  compare,
  compareNatural,
  compareText,
  // complex,
  composition,
  // concat,
  // conductanceQuantum,
  config,
  // conj,
  cos,
  cosh,
  cot,
  coth,
  // coulomb,
  // createUnit,
  // cross,
  csc,
  csch,
  // ctranspose,
  cube,
  deepEqual,
  // det,
  // deuteronMass,
  // diag,
  // distance,
  divide,
  divideScalar,
  // dot,
  // dotDivide,
  // dotMultiply,
  // dotPow,
  e,
  // efimovFactor,
  // electricConstant,
  // electronMass,
  // elementaryCharge,
  equal,
  equalScalar,
  equalText,
  erf,
  exp,
  // expm,
  expm1,
  // eye,
  factorial,
  false: _false,
  // faraday,
  // fermiCoupling,
  filter,
  // fineStructure,
  // firstRadiation,
  fix,
  // flatten,
  floor,
  forEach,
  format,
  // fraction,
  gamma,
  // gasConstant,
  gcd,
  // getMatrixDataType,
  // gravitationConstant,
  // gravity,
  // hartreeEnergy,
  hypot,
  // i,
  // identity,
  // im,
  // index,
  // intersect,
  // inv,
  // inverseConductanceQuantum,
  isInteger,
  isNaN,
  isNegative,
  isNumeric,
  hasNumericValue,
  isPositive,
  isPrime,
  isZero,
  // kldivergence,
  // klitzing,
  // kron,
  larger,
  largerEq,
  lcm,
  leftShift,
  log,
  log10,
  log1p,
  log2,
  // loschmidt,
  // lsolve,
  // lup,
  // lusolve,
  mad,
  // magneticConstant,
  // magneticFluxQuantum,
  // map,
  matrix, // FIXME: remove matrix here (subset.transform dependency)
  max,
  mean,
  median,
  min,
  mod,
  mode,
  // molarMass,
  // molarMassC12,
  // molarPlanckConstant,
  // molarVolume,
  multinomial,
  multiply,
  multiplyScalar,
  // neutronMass,
  norm,
  not,
  nthRoot,
  // nthRoots,
  // nuclearMagneton,
  null: _null,
  number,
  numeric,
  // ones,
  or,
  partitionSelect,
  permutations,
  phi,
  pi,
  pickRandom,
  // planckCharge,
  // planckConstant,
  // planckLength,
  // planckMass,
  // planckTemperature,
  // planckTime,
  pow,
  print,
  prod,
  // protonMass,
  // qr,
  quantileSeq,
  // quantumOfCirculation,
  random,
  randomInt,
  range,
  // re,
  // reducedPlanckConstant,
  // reshape,
  // resize,
  rightArithShift,
  rightLogShift,
  round,
  // rydberg,
  // sackurTetrode,
  sec,
  sech,
  // secondRadiation,
  // setCartesian,
  // setDifference,
  // setDistinct,
  // setIntersect,
  // setIsSubset,
  // setMultiplicity,
  // setPowerset,
  // setSize,
  // setSymDifference,
  // setUnion,
  sign,
  sin,
  sinh,
  // size,
  // slu,
  smaller,
  smallerEq,
  // sort,
  // sparse,
  // speedOfLight,
  // splitUnit,
  sqrt,
  // sqrtm,
  square,
  // squeeze,
  std,
  // stefanBoltzmann,
  stirlingS2,
  string,
  subset,
  subtract,
  sum,
  tan,
  tanh,
  tau,
  // thomsonCrossSection,
  // to,
  // trace,
  // transpose,
  true: _true,
  typeOf,
  typed,
  unaryMinus,
  unaryPlus,
  unequal,
  // unit,
  // usolve,
  // vacuumImpedance,
  variance,
  version,
  // weakMixingAngle,
  // wienDisplacement,
  xgcd,
  xor,
  // zeros,

  'var': variance,
  'typeof': typeOf,

  PI: pi,
  E: e,
  help,
  parse,
  parser,
  compile,
  evaluate,
  eval: evaluate,
  chain,
  simplify,
  derivative,
  rationalize,
  reviver
})

Object.assign(mathWithTransform, math, {
  apply: /* #__PURE__ */ createApplyTransform({ typed, isInteger }),
  // concat: /* #__PURE__ */ createConcatTransform({ typed, matrix, isInteger }),
  filter: /* #__PURE__ */ createFilterTransform({ typed }),
  forEach: /* #__PURE__ */ createForEachTransform({ typed }),
  // index: /* #__PURE__ */ createIndexTransform({ Index }),
  map: /* #__PURE__ */ createMapTransform({ typed }),
  max: /* #__PURE__ */ createMaxTransform({ typed, larger }),
  mean: /* #__PURE__ */ createMeanTransform({ typed, add, divide }),
  min: /* #__PURE__ */ createMinTransform({ typed, smaller }),
  range: /* #__PURE__ */ createRangeTransform({ typed, config, smaller, smallerEq, larger, largerEq }),
  subset: /* #__PURE__ */ createSubsetTransform({ typed, matrix }),
  sum: /* #__PURE__ */ createSumTransform({ typed, config, add }),
  std: /* #__PURE__ */ createStdTransform({ typed, sqrt, variance }),
  variance: /* #__PURE__ */ createVarianceTransform({ typed, add, subtract, multiply, divide, apply, isNaN })
})

Chain.createProxy(math)
